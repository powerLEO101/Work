//小心这个题目的一个坑，点对逆过来也是可以的
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
#define ll long long
const int M=200005;
const int mod=10007;
vector<ll>g[M];
ll n,u,v,dian[M],sumhe[M],sumping[M],ans,max1,max2,maxx;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&u,&v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for(int i=1;i<=n;i++)scanf("%d",&dian[i]);
    for(int i=1;i<=n;i++)
    {
        if(g[i].size()>1)//只要有两个或以上与它相连，那么就能算出一对联合权值
        {
            max1=0;max2=0;//记录每个点的次大值和最大值
            for(int j=0;j<g[i].size();j++)
            {
                sumhe[i]+=dian[g[i][j]];
                sumping[i]+=dian[g[i][j]]*dian[g[i][j]];
                if(dian[g[i][j]]>max1)
                {
                    max2=max1;
                    max1=dian[g[i][j]];
                    continue;
                }
                //不打else if或continue会错，而且错的很尴尬
                if(dian[g[i][j]]>max2)
                {
                    max2=dian[g[i][j]];
                }
            }
            maxx=max(maxx,max1*max2);
        }
        ans=(ans+sumhe[i]*sumhe[i]-sumping[i])%mod;
    }
    printf("%lld %lld\n",maxx,ans);
}